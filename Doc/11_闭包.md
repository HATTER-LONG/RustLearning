# 迭代器和闭包

## 闭包-使用闭包创建抽象行为

1. 闭包：可以捕获其所在环境的匿名函数。

   - 是匿名函数。
   - 可以保存为变量、作为参数。
   - 可在一个地方创建闭包，然后在另一个上下文中调用闭包来完成运算。
   - 可从其定义的作用域捕获值。

2. 例子-生成自定义运动计划的程序：

   - 目标：不让用户发生不必要的等待。
     - 仅在必要时调用该算法。
     - 只调用一次。

   ```rust
   use std::{thread, time::Duration};

   fn main() {
       let simulated_user_specified_value = 10;
       let simulated_random_number = 7;
       generate_workout(simulated_user_specified_value, simulated_random_number);
   }

   fn simulated_expensive_calculation(intensity: u32) -> u32 {
       println!("calculating slowly ....");
       thread::sleep(Duration::from_secs(2));
       intensity
   }

   fn generate_workout(intensity: u32, random_number: u32) {
       if intensity < 25 {
           println!(
               "Today, do {} pushups!",
               simulated_expensive_calculation(intensity)
           );
           println!(
               "Next, do {} situps!",
               simulated_expensive_calculation(intensity)
           );
       } else if random_number == 3 {
           println!("Take a break today! Remember to stay hydrated!");
       } else {
           println!(
               "Today, run for {} minutes!",
               simulated_expensive_calculation(intensity)
           );
       }
   }
   ```

3. 针对以上代码进行优化：

   - 方案一：提取耗时计算，但是存在一个问题当 random 等于 3 时同样运行了耗时函数。

   ```rust
   fn generate_workout(intensity: u32, random_number: u32) {
       let expensive_result = simulated_expensive_calculation(intensity);
       if intensity < 25 {
           println!("Today, do {} pushups!", expensive_result);
           println!("Next, do {} situps!", expensive_result);
       } else if random_number == 3 {
           println!("Take a break today! Remember to stay hydrated!");
       } else {
           println!("Today, run for {} minutes!", expensive_result);
       }
   }
   ```

   - 方案二：闭包方式。

   ```rust
   fn generate_workout(intensity: u32, random_number: u32) {
       let expensive_closure = |num| {
           println!("calculating slowly ....");
           thread::sleep(Duration::from_secs(2));
           num
       };
       if intensity < 25 {
           println!("Today, do {} pushups!", expensive_closure(intensity));
           println!("Next, do {} situps!", expensive_closure(intensity));
       } else if random_number == 3 {
           println!("Take a break today! Remember to stay hydrated!");
       } else {
           println!("Today, run for {} minutes!", expensive_closure(intensity));
       }
   }
   ```

   - 方法三：使用 struct，持有闭包函数与结果：
     - 只会在需要结果时才执行该闭包。
     - 可缓存结果。
     - struct 的定义需要知道所有字段的类型，因此需要指定闭包的类型。
       - 每个闭包实例都有自己唯一的匿名类型，即使两个闭包签名完全一致，因此需要使用范型和 Trait Bound（08 章讲解）。
       - `Fn Trait` 由标准库提供，所有闭包都至少实现了一下 trait 之一：
         - Fn。
         - FnMut。
         - FnOnce。

   ```rust
   use std::{thread, time::Duration};

   struct Cacher<T>
   where
       T: Fn(u32) -> u32,
   {
       calculation: T,
       value: Option<u32>,
   }

   impl<T> Cacher<T>
   where
       T: Fn(u32) -> u32,
   {
       fn new(calculation: T) -> Cacher<T> {
           Cacher {
               calculation,
               value: None,
           }
       }
       fn value(&mut self, arg: u32) -> u32 {
           match self.value {
               Some(v) => v,
               None => {
                   let v = (self.calculation)(arg);
                   self.value = Some(v);
                   v
               }
           }
       }
   }

   fn main() {
       let simulated_user_specified_value = 10;
       let simulated_random_number = 7;
       generate_workout(simulated_user_specified_value, simulated_random_number);
   }

   fn generate_workout(intensity: u32, random_number: u32) {
       let mut expensive_closure = Cacher::new(|num| {
           println!("calculating slowly ....");
           thread::sleep(Duration::from_secs(2));
           num
       });
       if intensity < 25 {
           println!("Today, do {} pushups!", expensive_closure.value(intensity));
           println!("Next, do {} situps!", expensive_closure.value(intensity));
       } else if random_number == 3 {
           println!("Take a break today! Remember to stay hydrated!");
       } else {
           println!(
               "Today, run for {} minutes!",
               expensive_closure.value(intensity)
           );
       }
   }
   ```

   - 缓存器的限制，嘉定针对不同的 arg 参数，value 方法总会得到同样的值。
     - 可以使用 HashMap 代替单个值：
       - key：arg 参数。
       - value：执行闭包结果。
     - 另一个限制：只能接收一个 u32 类型的参数和 u32 类型的返回值。

   ```rust
   #[cfg(test)]
   mod tests {
       #[test]
       fn call_with_different_values() {
           let mut c = super::Cacher::new(|a| a);
           let _v1 = c.value(1);
           let v2 = c.value(2);
           assert_eq!(v2, 2);
       }
   }
   ```

### 闭包的类型推断

1. 闭包不要求标注参数和返回值的类型。
2. 闭包通常很短小，只在狭小的上下文中工作，编译器通常能推断出类型。

   - 注意：闭包的定义最终只会为参数/返回值推断出唯一具体的类型（不会像模版一样）。

   ```rust
   /*
    --> src/main.rs:32:29
    |
    32 |     let n = example_closure(5);
    |                             ^ expected `&str`, found integer

    For more information about this error, try `rustc --explain E0308`.
    error: could not compile `simulated_expensive_calculation` due to previous error
    */

   let example_closure = |x| x;
   let s = example_closure("aa");
   let n = example_closure(5);
   ```
